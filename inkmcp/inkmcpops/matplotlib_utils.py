"""Matplotlib SVG detection and cleanup utilities.

Detects SVGs generated by matplotlib and applies cleanup to normalize
them before template application.

Deep cleanup (when template_data is provided):
- Spine removal: keep only bottom/left axes borders (Tufte style)
- Grid restyling: apply template grid color/width/style
- Data recoloring: remap data element colors to template palette
"""

import re
from typing import Dict, Any, List, Optional, Tuple

from lxml import etree


# Namespaces commonly found in matplotlib SVGs
MATPLOTLIB_NAMESPACES = {
    "dc": "http://purl.org/dc/elements/1.1/",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "svg": "http://www.w3.org/2000/svg",
}


def is_matplotlib_svg(svg_root: etree._Element) -> bool:
    """Detect if an SVG was generated by matplotlib.

    Checks for:
    1. dc:creator metadata containing 'matplotlib'
    2. Characteristic element IDs (figure_1, axes_1, patch_1, etc.)
    3. matplotlib-specific class attributes
    """
    nsmap = svg_root.nsmap if hasattr(svg_root, "nsmap") else {}

    # Check dc:creator metadata
    dc_ns = nsmap.get("dc", MATPLOTLIB_NAMESPACES["dc"])
    rdf_ns = nsmap.get("rdf", MATPLOTLIB_NAMESPACES["rdf"])

    for creator in svg_root.iter(f"{{{dc_ns}}}creator"):
        if creator.text and "matplotlib" in creator.text.lower():
            return True
    # Also check inside RDF descriptions
    for desc in svg_root.iter(f"{{{rdf_ns}}}Description"):
        for creator in desc.iter(f"{{{dc_ns}}}creator"):
            if creator.text and "matplotlib" in creator.text.lower():
                return True

    # Check characteristic IDs
    matplotlib_ids = {"figure_1", "axes_1", "patch_1", "matplotlib.axis_1"}
    found_ids = set()
    for elem in svg_root.iter():
        if not isinstance(elem.tag, str):
            continue  # Skip comments, PIs, etc.
        elem_id = elem.get("id", "")
        if not elem_id:
            continue
        if elem_id in matplotlib_ids:
            found_ids.add(elem_id)
        # matplotlib uses IDs like "figure_1", "axes_1", "patch_N"
        elif re.match(r"^(figure|axes|patch|text|line|PathCollection)_\d+$", elem_id):
            found_ids.add(elem_id)
        if len(found_ids) >= 2:
            return True

    # Check for matplotlib-specific comments
    svg_str = etree.tostring(svg_root, encoding="unicode")
    if "Created with matplotlib" in svg_str:
        return True

    return False


def cleanup_matplotlib_svg(
    svg_root: etree._Element,
    template_data: Optional[Dict[str, Any]] = None,
) -> int:
    """Clean up matplotlib-generated SVG for better template application.

    Basic cleanup (always applied):
    1. Remove full-size white background rectangles
    2. Remove redundant <style> blocks (defs styles)
    3. Normalize fonts from DejaVu Sans to sans-serif placeholder

    Deep cleanup (when template_data is provided):
    4. Remove/restyle spines (axes borders)
    5. Restyle grid lines
    6. Recolor data elements to template palette

    Args:
        svg_root: The SVG root element.
        template_data: Optional template dict with axes/colors config.

    Returns:
        Number of modifications made.
    """
    modifications = 0

    modifications += _remove_background_rects(svg_root)
    modifications += _remove_redundant_styles(svg_root)
    modifications += _normalize_matplotlib_fonts(svg_root)

    if template_data:
        axes_cfg = template_data.get("axes", {})
        colors_cfg = template_data.get("colors", {})

        modifications += _cleanup_spines(
            svg_root,
            keep_spines=axes_cfg.get("spines"),
            spine_color=colors_cfg.get("axis"),
            spine_width=axes_cfg.get("line_width"),
        )
        modifications += _cleanup_grid_lines(
            svg_root,
            grid_color=colors_cfg.get("grid"),
            grid_width=axes_cfg.get("grid_width"),
            grid_style=axes_cfg.get("grid_style"),
        )

        palette = colors_cfg.get("palette", [])
        if palette:
            from .color_utils import extract_data_colors, auto_map_colors
            data_colors = extract_data_colors(svg_root)
            if data_colors:
                color_map = auto_map_colors(data_colors, palette)
                modifications += _recolor_data_elements(svg_root, color_map)

    return modifications


def _remove_background_rects(svg_root: etree._Element) -> int:
    """Remove full-size white background rectangles."""
    count = 0
    svg_ns = svg_root.nsmap.get(None, "http://www.w3.org/2000/svg")

    # Get document dimensions for comparison
    doc_width = _parse_dimension(svg_root.get("width", "0"))
    doc_height = _parse_dimension(svg_root.get("height", "0"))

    if doc_width == 0 or doc_height == 0:
        # Try viewBox
        viewbox = svg_root.get("viewBox", "")
        if viewbox:
            parts = viewbox.split()
            if len(parts) == 4:
                doc_width = float(parts[2])
                doc_height = float(parts[3])

    to_remove = []
    for rect in svg_root.iter(f"{{{svg_ns}}}rect", "rect"):
        tag = rect.tag.split("}")[-1] if "}" in rect.tag else rect.tag
        if tag != "rect":
            continue

        style = rect.get("style", "")
        fill = rect.get("fill", "")

        # Check if it's a white/near-white fill
        is_white = False
        if "fill:#ffffff" in style.lower() or "fill:white" in style.lower():
            is_white = True
        if fill.lower() in ("#ffffff", "#fff", "white"):
            is_white = True

        if not is_white:
            continue

        # Check if it covers the full document
        r_width = _parse_dimension(rect.get("width", "0"))
        r_height = _parse_dimension(rect.get("height", "0"))
        r_x = _parse_dimension(rect.get("x", "0"))
        r_y = _parse_dimension(rect.get("y", "0"))

        if doc_width > 0 and doc_height > 0:
            covers_width = r_width >= doc_width * 0.95
            covers_height = r_height >= doc_height * 0.95
            at_origin = r_x <= doc_width * 0.05 and r_y <= doc_height * 0.05
        else:
            # Without doc dimensions, check for very large rects
            covers_width = r_width > 500
            covers_height = r_height > 500
            at_origin = r_x < 10 and r_y < 10

        if covers_width and covers_height and at_origin:
            to_remove.append(rect)

    for rect in to_remove:
        parent = rect.getparent()
        if parent is not None:
            parent.remove(rect)
            count += 1

    return count


def _remove_redundant_styles(svg_root: etree._Element) -> int:
    """Remove matplotlib's inline <style> blocks from <defs>."""
    count = 0
    svg_ns = svg_root.nsmap.get(None, "http://www.w3.org/2000/svg")

    for style in list(svg_root.iter(f"{{{svg_ns}}}style", "style")):
        tag = style.tag.split("}")[-1] if "}" in style.tag else style.tag
        if tag != "style":
            continue
        text = style.text or ""
        # matplotlib styles typically contain font definitions
        if "DejaVu" in text or "sans-serif" in text:
            parent = style.getparent()
            if parent is not None:
                parent.remove(style)
                count += 1

    return count


def _normalize_matplotlib_fonts(svg_root: etree._Element) -> int:
    """Replace matplotlib's DejaVu Sans with a generic sans-serif placeholder.

    This makes it easier for templates to then apply their own fonts.
    """
    count = 0
    dejavu_pattern = re.compile(r"font-family:\s*DejaVu Sans[^;]*", re.IGNORECASE)
    replacement = "font-family:sans-serif"

    for elem in svg_root.iter():
        style = elem.get("style", "")
        if style and dejavu_pattern.search(style):
            new_style = dejavu_pattern.sub(replacement, style)
            elem.set("style", new_style)
            count += 1

    return count


def _parse_dimension(value: str) -> float:
    """Parse an SVG dimension value, stripping units."""
    if not value:
        return 0.0
    # Remove common units
    cleaned = re.sub(r"(px|pt|mm|cm|in|em|%)$", "", str(value).strip())
    try:
        return float(cleaned)
    except (ValueError, TypeError):
        return 0.0


# ---------------------------------------------------------------------------
# Deep cleanup helpers
# ---------------------------------------------------------------------------

def _get_axes_groups(svg_root: etree._Element) -> List[etree._Element]:
    """Find all matplotlib axes groups (id like 'axes_N')."""
    axes = []
    for elem in svg_root.iter():
        if not isinstance(elem.tag, str):
            continue
        elem_id = elem.get("id", "")
        if re.match(r"^axes_\d+$", elem_id):
            axes.append(elem)
    return axes


def _is_rectilinear_path(d: str) -> Optional[Tuple[float, float, float, float]]:
    """Check if a path 'd' attribute is a single straight line (M...L or M...l).

    Returns (x1, y1, x2, y2) if it's a simple line, else None.
    """
    if not d:
        return None
    # Match M x,y L x,y  or  M x y L x y  (with optional Z)
    m = re.match(
        r"^\s*M\s*([\d.e+-]+)[,\s]+([\d.e+-]+)\s+L\s*([\d.e+-]+)[,\s]+([\d.e+-]+)\s*Z?\s*$",
        d.strip(),
        re.IGNORECASE,
    )
    if m:
        return (float(m.group(1)), float(m.group(2)),
                float(m.group(3)), float(m.group(4)))
    return None


def _classify_spine(
    line: Tuple[float, float, float, float],
    bbox: Tuple[float, float, float, float],
    tolerance: float = 5.0,
) -> Optional[str]:
    """Classify a rectilinear line as a spine position relative to bbox.

    Args:
        line: (x1, y1, x2, y2)
        bbox: (x_min, y_min, x_max, y_max) of the axes area
        tolerance: pixel tolerance for matching

    Returns:
        'top', 'bottom', 'left', 'right', or None.
    """
    x1, y1, x2, y2 = line
    bx_min, by_min, bx_max, by_max = bbox

    is_horizontal = abs(y1 - y2) < tolerance
    is_vertical = abs(x1 - x2) < tolerance

    if is_horizontal:
        # Check if it spans roughly the width of the axes
        span = abs(x2 - x1)
        axes_width = bx_max - bx_min
        if axes_width > 0 and span > axes_width * 0.5:
            mid_y = (y1 + y2) / 2.0
            if abs(mid_y - by_min) < tolerance:
                return "top"
            if abs(mid_y - by_max) < tolerance:
                return "bottom"

    if is_vertical:
        span = abs(y2 - y1)
        axes_height = by_max - by_min
        if axes_height > 0 and span > axes_height * 0.5:
            mid_x = (x1 + x2) / 2.0
            if abs(mid_x - bx_min) < tolerance:
                return "left"
            if abs(mid_x - bx_max) < tolerance:
                return "right"

    return None


def _get_axes_bbox(axes_group: etree._Element) -> Tuple[float, float, float, float]:
    """Estimate the bounding box of an axes group from its patch rect.

    matplotlib axes have a rect (usually patch_N) that defines the plot area.

    Returns:
        (x_min, y_min, x_max, y_max) or (0, 0, 0, 0) if not found.
    """
    for elem in axes_group:
        if not isinstance(elem.tag, str):
            continue
        tag = elem.tag.split("}")[-1] if "}" in elem.tag else elem.tag
        elem_id = elem.get("id", "")
        if tag == "rect" and re.match(r"^patch_\d+$", elem_id):
            x = _parse_dimension(elem.get("x", "0"))
            y = _parse_dimension(elem.get("y", "0"))
            w = _parse_dimension(elem.get("width", "0"))
            h = _parse_dimension(elem.get("height", "0"))
            if w > 0 and h > 0:
                return (x, y, x + w, y + h)
    return (0.0, 0.0, 0.0, 0.0)


def _cleanup_spines(
    svg_root: etree._Element,
    keep_spines: Optional[List[str]] = None,
    spine_color: Optional[str] = None,
    spine_width: Optional[str] = None,
) -> int:
    """Remove unwanted spines (axes borders) from matplotlib SVG.

    Spines are rectilinear paths directly inside axes_N groups that form
    the border of the plot area.

    Args:
        svg_root: SVG root element.
        keep_spines: List of spine positions to keep. Default: ["bottom", "left"].
        spine_color: Color for kept spines. Default: keep original.
        spine_width: Stroke width for kept spines. Default: keep original.

    Returns:
        Number of modifications made.
    """
    if keep_spines is None:
        keep_spines = ["bottom", "left"]

    count = 0
    axes_groups = _get_axes_groups(svg_root)

    for axes in axes_groups:
        bbox = _get_axes_bbox(axes)
        if bbox == (0.0, 0.0, 0.0, 0.0):
            continue

        # Find spine paths: direct children of axes group that are rectilinear
        # single-segment lines. matplotlib names spines as patch_N too, so we
        # identify them by geometry (rectilinear + spans the axes bbox).
        spine_candidates = []
        for child in axes:
            if not isinstance(child.tag, str):
                continue
            tag = child.tag.split("}")[-1] if "}" in child.tag else child.tag
            # Skip subgroups (axis_N, tick groups)
            if tag == "g":
                continue
            if tag != "path":
                continue
            child_id = child.get("id", "")
            # Skip multi-segment data paths (line2d_N, PathCollection_N)
            if re.match(r"^(line2d|PathCollection)_\d+$", child_id):
                continue
            d = child.get("d", "")
            line = _is_rectilinear_path(d)
            if line:
                spine_candidates.append((child, line))

        for elem, line in spine_candidates:
            position = _classify_spine(line, bbox)
            if position is None:
                continue

            if position not in keep_spines:
                # Remove this spine
                parent = elem.getparent()
                if parent is not None:
                    parent.remove(elem)
                    count += 1
            else:
                # Restyle kept spines
                if spine_color or spine_width:
                    style = elem.get("style", "")
                    if spine_color:
                        if "stroke:" in style:
                            style = re.sub(r"stroke:[^;]+", f"stroke:{spine_color}", style)
                        else:
                            style += f";stroke:{spine_color}"
                    if spine_width:
                        if "stroke-width:" in style:
                            style = re.sub(r"stroke-width:[^;]+", f"stroke-width:{spine_width}", style)
                        else:
                            style += f";stroke-width:{spine_width}"
                    elem.set("style", style)
                    count += 1

    return count


def _cleanup_grid_lines(
    svg_root: etree._Element,
    grid_color: Optional[str] = None,
    grid_width: Optional[str] = None,
    grid_style: Optional[str] = None,
) -> int:
    """Restyle or remove grid lines in matplotlib SVG.

    Grid lines are groups of parallel rectilinear paths inside axes_N
    with light grayscale stroke colors.

    Args:
        svg_root: SVG root element.
        grid_color: New grid color. If None, remove grid lines.
        grid_width: New grid stroke width.
        grid_style: Grid style: 'solid', 'dashed', 'dotted'. Default: keep.

    Returns:
        Number of modifications made.
    """
    from .color_utils import is_grayscale, color_lightness

    count = 0
    axes_groups = _get_axes_groups(svg_root)

    for axes in axes_groups:
        # Collect candidate grid paths: rectilinear, grayscale, light color
        h_lines = []  # horizontal
        v_lines = []  # vertical

        for child in axes:
            if not isinstance(child.tag, str):
                continue
            tag = child.tag.split("}")[-1] if "}" in child.tag else child.tag
            if tag != "path":
                continue
            child_id = child.get("id", "")
            # Skip known data/spine elements
            if re.match(r"^(line2d|PathCollection|patch)_\d+$", child_id):
                continue

            d = child.get("d", "")
            line = _is_rectilinear_path(d)
            if not line:
                continue

            # Check stroke color
            style = child.get("style", "")
            stroke_match = re.search(r"stroke:\s*([^;]+)", style)
            if not stroke_match:
                stroke_val = child.get("stroke", "")
            else:
                stroke_val = stroke_match.group(1).strip()

            if not stroke_val:
                continue

            # Normalize and check if it's a light grayscale
            from .color_utils import normalize_color
            norm_color = normalize_color(stroke_val)
            if not norm_color:
                continue
            if not is_grayscale(norm_color):
                continue
            L = color_lightness(norm_color)
            if L < 50:
                continue  # too dark to be grid (probably axis/spine)

            x1, y1, x2, y2 = line
            if abs(y1 - y2) < 1.0:
                h_lines.append(child)
            elif abs(x1 - x2) < 1.0:
                v_lines.append(child)

        # Only treat as grid if there are 3+ parallel lines
        for group in (h_lines, v_lines):
            if len(group) < 3:
                continue
            for elem in group:
                if grid_color is None:
                    # Remove grid
                    parent = elem.getparent()
                    if parent is not None:
                        parent.remove(elem)
                        count += 1
                else:
                    # Restyle grid
                    style = elem.get("style", "")
                    if "stroke:" in style:
                        style = re.sub(r"stroke:[^;]+", f"stroke:{grid_color}", style)
                    else:
                        style += f";stroke:{grid_color}"
                    if grid_width:
                        if "stroke-width:" in style:
                            style = re.sub(r"stroke-width:[^;]+", f"stroke-width:{grid_width}", style)
                        else:
                            style += f";stroke-width:{grid_width}"
                    if grid_style == "dashed":
                        if "stroke-dasharray:" in style:
                            style = re.sub(r"stroke-dasharray:[^;]+", "stroke-dasharray:4,4", style)
                        else:
                            style += ";stroke-dasharray:4,4"
                    elif grid_style == "dotted":
                        if "stroke-dasharray:" in style:
                            style = re.sub(r"stroke-dasharray:[^;]+", "stroke-dasharray:1,3", style)
                        else:
                            style += ";stroke-dasharray:1,3"
                    elem.set("style", style)
                    count += 1

    return count


def _recolor_data_elements(
    svg_root: etree._Element,
    color_map: Dict[str, str],
) -> int:
    """Recolor data elements (bars, lines, patches) using a color map.

    Targets elements inside axes_N groups with IDs matching matplotlib
    data patterns (patch_N, line2d_N, PathCollection_N).

    Args:
        svg_root: SVG root element.
        color_map: Dict mapping original hex colors to new hex colors.

    Returns:
        Number of modifications made.
    """
    if not color_map:
        return 0

    count = 0
    # Build case-insensitive lookup
    lower_map = {k.lower(): v for k, v in color_map.items()}

    axes_groups = _get_axes_groups(svg_root)

    for axes in axes_groups:
        for elem in axes.iter():
            if not isinstance(elem.tag, str):
                continue
            tag = elem.tag.split("}")[-1] if "}" in elem.tag else elem.tag
            elem_id = elem.get("id", "")

            # Target data elements: patch_N, line2d_N, PathCollection_N,
            # or any path/rect/circle inside axes (excluding axis groups)
            is_data = bool(re.match(
                r"^(patch|line2d|PathCollection)_\d+$", elem_id
            ))
            if not is_data and tag not in ("path", "rect", "circle"):
                continue

            # Skip axis/tick groups
            parent = elem.getparent()
            if parent is not None:
                parent_id = parent.get("id", "")
                if re.match(r"^matplotlib\.axis_\d+$", parent_id):
                    continue
                if re.match(r"^(x|y)tick_\d+$", parent_id):
                    continue

            style = elem.get("style", "")
            changed = False

            # Replace fill colors
            for prop in ("fill", "stroke"):
                # Check style attribute
                match = re.search(rf"{prop}:\s*([^;]+)", style)
                if match:
                    val = match.group(1).strip().lower()
                    if val in lower_map:
                        style = style[:match.start()] + f"{prop}:{lower_map[val]}" + style[match.end():]
                        changed = True

                # Check direct attribute
                attr_val = elem.get(prop, "").strip().lower()
                if attr_val and attr_val in lower_map:
                    elem.set(prop, lower_map[attr_val])
                    changed = True

            if changed:
                if style:
                    elem.set("style", style)
                count += 1

    return count

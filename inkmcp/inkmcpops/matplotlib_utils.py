"""Matplotlib SVG detection and cleanup utilities.

Detects SVGs generated by matplotlib and applies cleanup to normalize
them before template application.
"""

import re
from typing import Tuple

from lxml import etree


# Namespaces commonly found in matplotlib SVGs
MATPLOTLIB_NAMESPACES = {
    "dc": "http://purl.org/dc/elements/1.1/",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "svg": "http://www.w3.org/2000/svg",
}


def is_matplotlib_svg(svg_root: etree._Element) -> bool:
    """Detect if an SVG was generated by matplotlib.

    Checks for:
    1. dc:creator metadata containing 'matplotlib'
    2. Characteristic element IDs (figure_1, axes_1, patch_1, etc.)
    3. matplotlib-specific class attributes
    """
    nsmap = svg_root.nsmap if hasattr(svg_root, "nsmap") else {}

    # Check dc:creator metadata
    dc_ns = nsmap.get("dc", MATPLOTLIB_NAMESPACES["dc"])
    rdf_ns = nsmap.get("rdf", MATPLOTLIB_NAMESPACES["rdf"])

    for creator in svg_root.iter(f"{{{dc_ns}}}creator"):
        if creator.text and "matplotlib" in creator.text.lower():
            return True
    # Also check inside RDF descriptions
    for desc in svg_root.iter(f"{{{rdf_ns}}}Description"):
        for creator in desc.iter(f"{{{dc_ns}}}creator"):
            if creator.text and "matplotlib" in creator.text.lower():
                return True

    # Check characteristic IDs
    matplotlib_ids = {"figure_1", "axes_1", "patch_1", "matplotlib.axis_1"}
    found_ids = set()
    for elem in svg_root.iter():
        if not isinstance(elem.tag, str):
            continue  # Skip comments, PIs, etc.
        elem_id = elem.get("id", "")
        if not elem_id:
            continue
        if elem_id in matplotlib_ids:
            found_ids.add(elem_id)
        # matplotlib uses IDs like "figure_1", "axes_1", "patch_N"
        elif re.match(r"^(figure|axes|patch|text|line|PathCollection)_\d+$", elem_id):
            found_ids.add(elem_id)
        if len(found_ids) >= 2:
            return True

    # Check for matplotlib-specific comments
    svg_str = etree.tostring(svg_root, encoding="unicode")
    if "Created with matplotlib" in svg_str:
        return True

    return False


def cleanup_matplotlib_svg(svg_root: etree._Element) -> int:
    """Clean up matplotlib-generated SVG for better template application.

    Modifications:
    1. Remove full-size white background rectangles
    2. Remove redundant <style> blocks (defs styles)
    3. Normalize fonts from DejaVu Sans to sans-serif placeholder

    Returns:
        Number of modifications made.
    """
    modifications = 0

    modifications += _remove_background_rects(svg_root)
    modifications += _remove_redundant_styles(svg_root)
    modifications += _normalize_matplotlib_fonts(svg_root)

    return modifications


def _remove_background_rects(svg_root: etree._Element) -> int:
    """Remove full-size white background rectangles."""
    count = 0
    svg_ns = svg_root.nsmap.get(None, "http://www.w3.org/2000/svg")

    # Get document dimensions for comparison
    doc_width = _parse_dimension(svg_root.get("width", "0"))
    doc_height = _parse_dimension(svg_root.get("height", "0"))

    if doc_width == 0 or doc_height == 0:
        # Try viewBox
        viewbox = svg_root.get("viewBox", "")
        if viewbox:
            parts = viewbox.split()
            if len(parts) == 4:
                doc_width = float(parts[2])
                doc_height = float(parts[3])

    to_remove = []
    for rect in svg_root.iter(f"{{{svg_ns}}}rect", "rect"):
        tag = rect.tag.split("}")[-1] if "}" in rect.tag else rect.tag
        if tag != "rect":
            continue

        style = rect.get("style", "")
        fill = rect.get("fill", "")

        # Check if it's a white/near-white fill
        is_white = False
        if "fill:#ffffff" in style.lower() or "fill:white" in style.lower():
            is_white = True
        if fill.lower() in ("#ffffff", "#fff", "white"):
            is_white = True

        if not is_white:
            continue

        # Check if it covers the full document
        r_width = _parse_dimension(rect.get("width", "0"))
        r_height = _parse_dimension(rect.get("height", "0"))
        r_x = _parse_dimension(rect.get("x", "0"))
        r_y = _parse_dimension(rect.get("y", "0"))

        if doc_width > 0 and doc_height > 0:
            covers_width = r_width >= doc_width * 0.95
            covers_height = r_height >= doc_height * 0.95
            at_origin = r_x <= doc_width * 0.05 and r_y <= doc_height * 0.05
        else:
            # Without doc dimensions, check for very large rects
            covers_width = r_width > 500
            covers_height = r_height > 500
            at_origin = r_x < 10 and r_y < 10

        if covers_width and covers_height and at_origin:
            to_remove.append(rect)

    for rect in to_remove:
        parent = rect.getparent()
        if parent is not None:
            parent.remove(rect)
            count += 1

    return count


def _remove_redundant_styles(svg_root: etree._Element) -> int:
    """Remove matplotlib's inline <style> blocks from <defs>."""
    count = 0
    svg_ns = svg_root.nsmap.get(None, "http://www.w3.org/2000/svg")

    for style in list(svg_root.iter(f"{{{svg_ns}}}style", "style")):
        tag = style.tag.split("}")[-1] if "}" in style.tag else style.tag
        if tag != "style":
            continue
        text = style.text or ""
        # matplotlib styles typically contain font definitions
        if "DejaVu" in text or "sans-serif" in text:
            parent = style.getparent()
            if parent is not None:
                parent.remove(style)
                count += 1

    return count


def _normalize_matplotlib_fonts(svg_root: etree._Element) -> int:
    """Replace matplotlib's DejaVu Sans with a generic sans-serif placeholder.

    This makes it easier for templates to then apply their own fonts.
    """
    count = 0
    dejavu_pattern = re.compile(r"font-family:\s*DejaVu Sans[^;]*", re.IGNORECASE)
    replacement = "font-family:sans-serif"

    for elem in svg_root.iter():
        style = elem.get("style", "")
        if style and dejavu_pattern.search(style):
            new_style = dejavu_pattern.sub(replacement, style)
            elem.set("style", new_style)
            count += 1

    return count


def _parse_dimension(value: str) -> float:
    """Parse an SVG dimension value, stripping units."""
    if not value:
        return 0.0
    # Remove common units
    cleaned = re.sub(r"(px|pt|mm|cm|in|em|%)$", "", str(value).strip())
    try:
        return float(cleaned)
    except (ValueError, TypeError):
        return 0.0
